<h2>Things dicsussed in this documentation</h2>
<li> 1. Prototypical Inheritance in JS</li>
<li> 2. Scope in JS</li>
<li> 3. Function Declaration and Function Expression</li>


<h2>Prototypical Inheritance in JS</h2>
In JavaScript when one object inherits from another prototypically, you are able to access all the properties and methods from theparent object.
<pre><code>
[js]
    var obj1 = {
      someProp: 'obj1 property!',
      someMethod: function () {
        alert('obj1 method!');
      }
    };
    var obj2 = Object.create(obj1);
    obj2.someProp = 'obj2 property!';
[js]
</code></pre>

You might think from the above code that someProp was <span class='quoted'>"changed"</span> from  <span class='quoted'>"obj1 property!"</span> to  <span class='quoted'>"obj2 property!"</span> when obj2 was 
instantiated. However, you can not change properties on an  <span class='quoted'>"object's prototype"</span> like that. All that code did was  <span class='quoted'>"create a property"</span> 
called <span class='quoted'>"someProp"</span> on <span class='quoted'>"obj2"</span> that <span class='quoted'>"masks"</span> the value of the  <span class='quoted'>"underlying someProp on obj1".</span> If you run  <span class='quoted'>"delete obj2.someProp"</span> then 
 <span class='quoted'>"someProp won't be gone",</span> it will  <span class='quoted'>"revert to showing"</span> the value of <span class='quoted'>"obj1.someProp".</span> This is the way  <span class='quoted'>"nested scopes"</span> work. Setting a 
property on a  <span class='quoted'>"child scope"</span> does not  <span class='quoted'>"change the property"</span> with the same name on the <span class='quoted'>"hides"</span> 



<h2>Scope in JS</h2>

<h2>There are only two scopes</h2>
<li> 1. Function scope</li>
<li> 2. Global scope</li>

Function are the atomic unit of the <span class='quoted'>"scope".</span> 

<h2>When we define something like below</h2>

<h3> Compilation phase :</h3>
<pre><code>
[js]
        var foo = "bar"; /* declaration */ /* while compiling this one statement gets broken into two */
                /* the declaration part using var */
                /* the assignment part */

        function bar() { /* declaration */
            var foo = "bar"; /* declaration */
        }

        function baz(foo) { /* declaration of function as well as foo */
            foo = "bam";
            bam = "yay";
        }
[js]
</code></pre>

<h2>First thing to note about the above code is</h2>
JS do JIT(Just in time) compilation, which means function are not compiled when they are defined but they getscompiled and called at the time of call.
Second everything is scoped.
So, the very first line has a scope of <span class='quoted'>'global'</span> 

while <span class='quoted'>"foo"</span> inside the <span class='quoted'>"bar"</span> function has the scope of <span class='quoted'>"bar"</span> 

When the js compiles the <span class='quoted'>"baz"</span> function, it treats the  <span class='quoted'>"argument as a declaration".</span> 
So <span class='quoted'>"foo"</span> in the argument will be treated as a local variable. 
And the <span class='quoted'>"scope"</span> will be of <span class='quoted'>"baz".</span> 


<h3> Execution phase :</h3>
Now we have to note that there will be no <span class='quoted'>"var"</span> in the execution phase. 
So the first line will be : foo = <span class='quoted'>"bar"</span> 
without any <span class='quoted'>"var".</span> 

So even if we define  <span class='quoted'>"var foo"</span> 100 times, while execution it will be ignored. 
So defining var foo in somewhere in our program has no impact on the rest as that will be ignored.
<h2>Compiler terminologies</h2>
<span class='quoted'>"lhs"</span> : left hand side 
<span class='quoted'>"rhs"</span> : right hand side 

of an assignment.In our language its the <span class='quoted'>"="</span> sign. 

<h2>So in first line</h2>
<li> 1. foo will be our lhs reference</li>
<li> 2. "bar" will be our rhs reference</li>

But <span class='quoted'>"lhs"</span> and <span class='quoted'>"rhs"</span> can occur without assignment operator. 
<h2>So to need to understand them in some other way which is</h2>
<span class='quoted'>"lhs"</span> : *the target* 
<span class='quoted'>"rhs"</span> : *the source* 

SO in case of function <span class='quoted'>"argument"</span> there is an implicit assignment. 

When we execute the function <span class='quoted'>"bar"</span> we will ask the scope of bar that wheater 
it knows about the <span class='quoted'>"foo"</span> which happens to be the <span class='quoted'>"lhs".</span> 

<h2>When we execute the baz</h2>
We will ask scope of <span class='quoted'>"baz",</span> wheater it knows 
about an <span class='quoted'>"identifier"</span> named <span class='quoted'>"foo"</span> which happens to be 
the <span class='quoted'>"lhs".</span> 

So it will say that: yes, its in my declaration.
But when we execute the line: bam = <span class='quoted'>"yay"</span> 
We will ask <span class='quoted'>"baz"</span> that wheater it 
heard about an <span class='quoted'>"lhs"</span> identifier named 
<span class='quoted'>"bam".</span> 
It will say: no.
<h2>Now where do we go</h2>
 <span class='quoted'>"We go outer one level".</span> 
So it will be our <span class='quoted'>"global"</span> scope 
in this case.
So we will ask our <span class='quoted'>"global"</span> scope, wheater it 
knows any identifier named <span class='quoted'>"bam"</span> which happens to 
be the <span class='quoted'>"lhs".</span> 

And it will say: <span class='quoted'>"yes",</span> i have just created it for you. 
The <span class='quoted'>"global"</span> scope will create <span class='quoted'>"bam"</span> for us because 
we have an <span class='quoted'>"lhs"</span> reference. 

Note: * this thing is in non strict mode *
* So this assignment will create a global variable *
And thats why we get the idea of leakage ofglobal variables.
but when we will be in  <span class='quoted'>"strict mode"</span> the global 
scope will say it does not knows.
While passing <span class='quoted'>"foo"</span> in the function <span class='quoted'>"baz",</span> 
even if we try to redeclare <span class='quoted'>"foo"</span> using 
 <span class='quoted'>"var foo",</span> the compiler will ignore it as 
it has <span class='quoted'>"foo"</span> already. 

<h3> Note :</h3>
In js <span class='quoted'>"undeclared"</span> and <span class='quoted'>"undefined"</span> are two different 
words.
<span class='quoted'>"undefined"</span> : when we declare but it contains empty value. 

<span class='quoted'>"undefined"</span> is more like <span class='quoted'>"uninitialised".</span> 

<span class='quoted'>"undefined"</span> is an actual value. 


<h2>Example</h2>

<pre><code>
[js]
    var foo = "bar";

    function bar() {
      var foo = "baz";

      function baz(foo) {
        foo = "bam";
        bam = "yay";
      }
      baz();
    }

    bar();
    foo;
    bam;
    baz();

[js]
</code></pre>

<h2>While compiling we will say</h2>
hey  <span class='quoted'>"global scope"</span> i have a declaration for 
variable called <span class='quoted'>"foo".</span> 

For compiling the <span class='quoted'>"baz"</span> function it will ask 
the scope of <span class='quoted'>"bar"</span> to register the function <span class='quoted'>"baz".</span> 

While executing when we will go to the <span class='quoted'>"bar()".</span> 
We will ask: hey global scope do you have a <span class='quoted'>"rhs"</span> 
reference <span class='quoted'>"bar".</span> 

* Note *: bar() will be an <span class='quoted'>"rhs"</span> not <span class='quoted'>"lhs"</span> because 
there is no assignment going on at this point of time.
So it will say <span class='quoted'>"yes"</span> and it will return the 
 <span class='quoted'>"function object bar".</span> 

We have <span class='quoted'>"()"</span> after the <span class='quoted'>"bar",</span> so bar will have function 
object and <span class='quoted'>"()"</span> will be used for calling the function. 


<h2>* Note *</h2>
In case we ask some <span class='quoted'>"rhs"</span> value which is not 
declared in the scope, the behaivior is different.
The global scope does not create one for us ifits a <span class='quoted'>"rhs".</span> And it will throw a reference error. 

This is common to <span class='quoted'>"restrict"</span> and <span class='quoted'>"unrestrict"</span> mode. 



<h2>Function Declaration and Function Expression</h2>

<pre><code>
[js]
    var foo = function bar() {
      var foo = "baz";

      function baz(foo) {
        foo = bar;
        foo;
      }
      baz();
    };

    foo();
    bar();

[js]
</code></pre>

If the <span class='quoted'>"function"</span> keyword is the first word in the 
statement then its a function declaration.
Otherwise it will be <span class='quoted'>"Expressions".</span> 

In our case it is function <span class='quoted'>"expression"</span> rather than 
declaration.
Most of the time function expressions are anonymousfunction, but in our case it is  <span class='quoted'>"named anonymous"</span> function. 

As the first line in our code is function expression,<span class='quoted'>"bar"</span> will not get defined in the outer scope. 

In case of function expression, the name of thefunction is enclosed in its own scope.
So the name <span class='quoted'>"bar"</span> exists throughout the function. 

So calling  <span class='quoted'>"foo = bar"</span> is fine. But <span class='quoted'>"bar"</span> does not 
exists in the global scope.So calling <span class='quoted'>"bar()"</span> at the last line will raise 
 <span class='quoted'>"reference error".</span> 

<h2>Why we should use named anonymous function expression</h2>
When we use anonymous function expression there are<h2>three downside</h2>
<li> 1. When we dont use named anonymous function expression we "dont have any way to refer" to ourself. This property is required when we do recursion, or when we bind some event to our function. (name is necessary) (many people think that "this" keyword is a reference to itself but it is not.)</li>
<li> 2. Anonymous function expression pose problem while debugging. So giving a name is always helpful.</li>
<li> 3. We dont need to look outside to know what is being done by the function.</li>
<h2>ex</h2>
when we give name as <span class='quoted'>"handler"</span> it is evident 
that this function is handling something.

<h2>Try catch in JS</h2>
In Es3, <span class='quoted'>"try"</span> <span class='quoted'>"catch"</span> was added, and according to the 
specification, <span class='quoted'>"catch"</span> has <span class='quoted'>"block"</span> scope. 

Meaning, the variable which you will declare in the<span class='quoted'>"catch"</span> clause will only be accessible in the <span class='quoted'>"catch"</span> clause 
and not outside.
<pre><code>
[js]
    var foo;
    try {
      foo.length;
    }

    catch (err) {
      console.log(err);
    }

    console.log(err); // ReferenceError.

[js]
</code></pre>

So here <span class='quoted'>"err"</span> cant be accessed from outside. 


<h2>Scope Models in JS</h2>
<h2>There are two</h2>
<li> 1. Lexical scope which we were talking till now. (lex refers to the lexing that occurs in the compiler) (lexical scope means "compile time scope")</li>
<li> 2. Dynamic scope (not present in js) (run time scope)</li>

<h2>IIFE Pattern (immediately invoked function expression)</h2>
<pre><code>
[js]
    var foo = "foo";

    (function() {

      var foo = "foo2";
      console.log(foo); // "foo2"
    })();

    console.log(foo); // "foo"

[js]
</code></pre>

When we want to keep some statements insegregated scope, we use this pattern.In this pattern an <span class='quoted'>"anonymous"</span> <span class='quoted'>"function"</span> 
<span class='quoted'>"expression"</span> has been used and is executed 
rite away.
We can have  <span class='quoted'>"named function expression"</span> rather 
than <span class='quoted'>"anonymous"</span> function expression. 
But that thing will give out the <span class='quoted'>"name".</span> 

And we wanted to hide our code in some otherscope which will not gets accessed from outside.
link to blog: http://benalman.com/news/2010/11/immediately-invoked-function-expression/

<h2>Hoisting</h2>
Its not a proper word in the specs, its onlybeing used to define the js behaiviors.
<h2>consider the below code</h2>
<pre><code>
[js]
      a;
      b;
      var a = b;
      var b = 2;
      b;
      a;

[js]
</code></pre>

what will happen if we execute this code?
<h2>Before executing there will be compilation</h2>
During which the compiler will find the declarationfirst.
<h2>so the above code will transform into</h2>
<pre><code>
[js]
        var a;
        var b;
        a;
        b;
        a = b;
        b = 2;
        b;
        a;

[js]
</code></pre>

In the above code the compiler moves the declarationof <span class='quoted'>"a"</span> and <span class='quoted'>"b"</span> to the top. 
They were treated first. <span class='quoted'>"This movement of declaration to the top"</span> is called <span class='quoted'>"hoisting".</span> 

So the compile phase will be line 1 and 2.
All the function and variable declaration will gethoisted.
* Note *: the function expression does <span class='quoted'>"not"</span> get <span class='quoted'>"hoisted".</span> 

So the below code<pre><code>
[js]
      var a = b();
      var c = d();
      a;
      c;

      function b() {
        return c;
      }

      var d = function() {
        return b();
      };
[js]
</code></pre>

Will be converted to
<pre><code>
[js]

      function b() {
        return c;
      }
      var a;
      var c;
      var d;
      a = b();
      c = d();
      a;
      c;
      d = function() {
        return b();
      };

[js]
</code></pre>

*Note*: Functions are hoisted before variables.
<h2>Consider the below code</h2>

<pre><code>
[js]
    foo();

    var foo = 2;

    function foo() {
      console.log("bar");
    }

    function foo() {
      console.log("foo");
    }

[js]
</code></pre>

In this case first function <span class='quoted'>"foo"</span> containing <span class='quoted'>"bar"</span> will be 
hoisted. Then the function <span class='quoted'>"foo"</span> containing <span class='quoted'>"foo"</span> 
will be hoisted which will override the previoushoisted value.
Then the variable foo gets hoisted and it will beignored as there is already a variable called <span class='quoted'>"foo"</span> 
and it holds the last function.
<h2>*Note*</h2>
<h2>* Mutual recursion *</h2>
Two function calling each other till aterminating condition is reached iscalled Mutually recursive function.
And mutual recursion is not possiblein a language where there is not <span class='quoted'>"hoisting".</span> 

 <span class='quoted'>"header files in c language"</span> are manual hoisting. 
we are putting the declaration part on the topof everything.
Js automatically do hoisting.

<h2>The "this" keyword</h2>
Every function, while executing, has a referenceto its current execution context, called <span class='quoted'>"this".</span> 

Execution context include far more than <span class='quoted'>"this"</span> keyword, 
but we are only interested in <span class='quoted'>"this".</span> 

 <span class='quoted'>"Execution context"</span> means : where the function has been 
called and how the function has been called.
There are four rules for how the <span class='quoted'>"this"</span> keyword is bound. 

<h2>And it all depends on call sight</h2>
(It is the place in code where the function is executed)
<h2>Four rules</h2>
<li> 1. "Default binding rule" (4th according to preference)</li>
<h2>ex</h2>
<pre><code>
[js]
          function foo() {
            console.log(this.bar);
          }

          var bar = "bar1";
          var o2 = {bar: "bar2", foo: foo};
          var o3 = {bar: "bar3", foo: foo};

          foo(); // here there is only reference to the function
                // and nothing else.
                // In these situation, the default binding rule
                // applies.
                // This is also true with the IIFIs.
          o2.foo();
          o3.foo();

[js]
</code></pre>

<h2>Default rule says</h2>
a. If you are in strict mode, default to <span class='quoted'>"this"</span> keyword 
is <span class='quoted'>"undefined"</span> value. 

b. If not, default to <span class='quoted'>"this"</span> keyword is global object. 

<h3> Note : In js everything is a reference to an object.</h3>
In the above code we have two reference to the <span class='quoted'>"foo".</span> 

First is: our <span class='quoted'>"global"</span> variable is referencing the <span class='quoted'>"foo".</span> 
Second: o2.foo is alos referencing the <span class='quoted'>"foo".</span> 

<li> 2. "Implicit binding rule": ( 3rd according to preference )</li>
<h2>Consider the above code</h2>
we have o2 and o3 which have same function <span class='quoted'>"foo".</span> 
So we have an  <span class='quoted'>"implicit reference"</span> for <span class='quoted'>"foo".</span> 

<span class='quoted'>"this.bar"</span> <span class='quoted'>"</span> 


<h3> Note :</h3>
<h3> Binding confusion :</h3>
<pre><code>
[js]

            function foo() {
              var bar = "bar1";
              baz();
            }

            function baz() {
              console.log(this.bar)

            }

            var bar = "bar2";
            foo();

[js]
</code></pre>

This code is fake but the concept is real.Here the function <span class='quoted'>"baz"</span> is some third party 
function on which the user does not have anycontroll but user knows that this function isusing <span class='quoted'>"this.bar"</span> somewhere in the code, on the 
other hand user have another function <span class='quoted'>"foo"</span> on 
which user have controll. Now user have defined<span class='quoted'>"bar"</span> locally and is trying to call <span class='quoted'>"bar()"</span> in 
a hope of referencing the  <span class='quoted'>"local variable bar".</span> 

Note: <span class='quoted'>"</span> 
 <span class='quoted'>"lexical environment and the this mechanism"</span> 

They are just two fundamentally differentmechanism and they dont cross over.
The above code was not doing what was expected from it.
<h2>The incorrect solution</h2>
<pre><code>
[js]

            function foo() {
              var bar = "bar1";
              this.baz = baz;
              this.baz();
            }

            function baz() {
              console.log(this.bar);
            }

            var bar = "bar2";
            foo();

[js]
</code></pre>

<h2>How the above code is wrong</h2>
<span class='quoted'>"this"</span> reference gets set by the sight of call. 
In our code we need to find what is being referencedby the <span class='quoted'>"this"</span> keyword. 

As we can see that the function <span class='quoted'>"foo"</span> is 
being called from the global scope, so<span class='quoted'>"this"</span> will point to the global object as 
we are in not strict mode.
<h2>So when we are saying </h2>
this.baz = baz in function <span class='quoted'>"foo".</span> 
We are actually sayingglobal.baz = bazbut global.baz is already there.
when we are calling the <span class='quoted'>'baz'</span> function in 
our <span class='quoted'>"foo"</span> function, 
this.baz(): here the implicit rule appliesas we are calling <span class='quoted'>"object.function()"</span> 
but the <span class='quoted'>"object"</span> is still <span class='quoted'>"global"</span> object. 
so it will be <span class='quoted'>"global.baz()".</span> 

<li> 3. "Explicit scope":</li>
<pre><code>
[js]
        function foo() {
          console.log(this.bar);
        }

        var bar = "bar1";
        var obj = {bar: "bar2"};

        foo();            // bar1
        foo.call(obj);    // bar2

[js]
</code></pre>

<h2>Explicit binding say that</h2>
If we use <span class='quoted'>".call()"</span> or <span class='quoted'>".apply()"</span> at the call sight, 
both of these utilities take their  <span class='quoted'>"first parameter"</span> 
as <span class='quoted'>"this"</span> binding. 

<h2>* Problem with this keyword generality *</h2>

In case of a controller, when we have <span class='quoted'>"this"</span> 
pointing to the controller object, we can do allour work by just using controller.mthd.
But when we do an ajax call, the things get a bitdifferent. We say in the callback i want to call my<h2>controller method </h2>
we pass an reference to the controller method.But when it gets called the <span class='quoted'>"this"</span> binding gets 
<span class='quoted'>"wrong",</span> it will  <span class='quoted'>"fall back"</span> to the <span class='quoted'>"global".</span> 


Or say we have attached it to an event handlerlike a  <span class='quoted'>"click handler"</span> on a button. When i click 
the button, i want my controller method toinvoked but we will get frustrated because <span class='quoted'>"this"</span> 
binding becomes the <span class='quoted'>"button"</span> itself rather than 
my  <span class='quoted'>"controller object".</span> 

* solution  *<span class='quoted'>"this"</span> 
keyword reference.
<h2>ex</h2>
<pre><code>
[js]
            function foo() {
              console.log(this.bar);
            }

            var obj = {bar: "bar"};
            var obj2 = {bar: "bar2"};

            var orig = foo;
            foo = function() {orig.call(obj);};

            foo();    // "bar"
            foo.call(obj2);  // ???
[js]
</code></pre>

In the above code, everything is same apart fromdeclaration of <span class='quoted'>"orig"</span> variable and assigning it 
<span class='quoted'>'foo'.</span> Now in the next line, we are overriding the 
foo with a function expression, and <span class='quoted'>'forcing'</span> the 
call to <span class='quoted'>'foo'</span> to the original <span class='quoted'>'foo'</span> but fixing the 
<span class='quoted'>'this'</span> reference to the <span class='quoted'>'obj'.</span> 

So both the function call will print <span class='quoted'>"bar".</span> 

<h2>*Making an binding utility*</h2>
<pre><code>
[js]
          function bind(fn, o) {
            return function() {
              fn.call(o);
            };
          }
          function foo() {
            console.log(this.bar);
          }

          var obj = {bar: "bar"};
          var obj2 = {bar: "bar2"};

          foo = bind(foo, obj);

          foo();           // "bar"
          foo.call(obj2);
[js]
</code></pre>

This code is same as the above one.But it does not have any variable inglobal scope whose reference can beover written.But in this code too we are creating oneglobal utility.
Also the utility in this code does not havereturn statement(we cant return anything from the func.)And we can not pass arguments too.
soln: putting the utility on the prototype of functionitself.
<pre><code>
[js]
        // we are calling our utility "bind2" temporarily.
        if (!Function.prototype.bind2) {
          Function.prototype.bind2 =
              function(o) {
                var fn = this; // the function!
                // when we will look at the call sight
                // we will find that the utility is
                // a function, so 'this' will apply to it.
                // also we are calling it using 'implicit'
                // binding of 'foo'. So 'this' will point to
                // 'foo'.
                return function() {
                  return fn.apply(o, arguments);
                };
              };
        }

        function foo(baz) {
          console.log(this.bar + " " + baz);
        }

        var obj = {bar: "bar"};
        foo = foo.bind2(obj);

        foo("baz")    // "bar baz"

[js]
</code></pre>
In this code the utility has a return statement soit is capable of returning some values, alsowe will be able to pass arguments in this utility.
It is so common that the JavaScript has a <span class='quoted'>"bind()"</span> 
function on the function <span class='quoted'>'prototype'.</span> 
So we dont need our <span class='quoted'>'bind2'</span> utility. Its built-in. 
(In ECMAScript 5)
When we go to the MDN page for binding, they have apolyfills(they are to provide support for older browser).So we can use the <span class='quoted'>'bind'</span> utility in older browser too. 


<li> 4. "new keyword": (please set aside any conception about the 'new' keyword) (In other language 'new' keyword is used for instantiating the classes but</li>

<li> 1. JavaScript does not have classes</li>
<li> 2. 'new' keyword has nothing to do with the instantiation )</li>

<pre><code>
[js]
        function foo() {
          this.baz = "baz";
          console.log(this.bar + " " + baz);  // undefined undefined
        }

        var bar = "bar";
        var baz = new foo();
[js]
</code></pre>

When we put the <span class='quoted'>'new'</span> keyword in front of any function 
call, it magically turns that  <span class='quoted'>'function call'</span> into a 
<span class='quoted'>'constructor'</span> call. 

When we put the <span class='quoted'>'new'</span> keyword in front of any function 
<h2>call, it's going to do 4 things</h2>
<li> 1. A brand new empty 'object' will be created.</li>
<li> 2. * The new empty 'object' gets 'linked' to a different object.</li>
<li> 3. the brand new empty object get 'bound' as the 'this' keyword for the purposes of that function call.</li>
<li> 4. If that function does not otherwise return anything. Then it will implicitily insert, between line 3 and half of the above code, a 'return' 'this'. That is the brand new object get returned for the purposes of the call.</li>

So in the above code, when we call <span class='quoted'>'foo'</span> function with 
the <span class='quoted'>'new'</span> keyword, an object as the <span class='quoted'>'this'</span> reference 
will get returned.
So we can have one variable on <span class='quoted'>'this'</span> as <span class='quoted'>'baz',</span> but 
when we try to access <span class='quoted'>'this.bar',</span> as there is nothing 
called <span class='quoted'>'bar'</span> on <span class='quoted'>'this',</span> therefore, <span class='quoted'>'undefined'</span> will 
gets printed.
And at the moment, <span class='quoted'>'baz'</span> variable exists but it does not 
have any value so we will print <span class='quoted'>'undefined'</span> again. 

But final thing is that, there is a implicit <span class='quoted'>'return'</span> 
<span class='quoted'>'this',</span> so the newly created object gets assigned 
to our <span class='quoted'>'baz'</span> variable. 

So if we try <span class='quoted'>'baz.baz'</span> we will get the string value <span class='quoted'>'baz'.</span> 


<h2>How 'this' binding works</h2>
<h2>Ask these questions</h2>
<li> 1. was the function called with 'new' keyword ? If so, use that object. Which means the 'new' keyword is able to  override any of the other rules as it is most 'precedent' of the rules.</li>
<li> 2. Was the function called with 'call' or 'apply' specifying an explicit 'this'? If so, use that object.</li>
<li> 3. was the function called via a containing/ owning object(context) ?</li>
<li> 4. Default: global object (except strict mode)</li>

 <span class='quoted'>'hard bound'</span> functions are a variation of explicit binding 
rule.
So, what will be the precedence of 
ans: At no 2, which means the <span class='quoted'>'new'</span> keyword is able to 
override the 

<h2>Closure</h2>
<h2>def</h2>
Closure is when a function <span class='quoted'>"remembers"</span> its  <span class='quoted'>"lexical scope"</span> 
even when the function is executed  <span class='quoted'>"outside that lexical"</span> 
scope.
<h2>ex</h2>
<pre><code>
[js]
      function foo() {
        var bar = "bar";

        function baz() {
          console.log(bar);
        }

        bam(baz);
      }

      function bam(baz) {
        baz();        // "bar"
      }

      foo();
[js]
</code></pre>

<h2>*note*</h2>
if we keep a reference to an object, that does not get<span class='quoted'>"garbage"</span> collected. 

Similarly untill we have atleat one function referencingthe <span class='quoted'>"scope"</span> object, through <span class='quoted'>'closure',</span> <span class='quoted'>"scope"</span> does not 
gets garbage collected.

<h2>prob</h2>
<h2>consider the below code</h2>
<pre><code>
[js]
        for (var i = 1; i <= 5; i++) {
          setTimeout(function() {
            console.log("i: " + i);
          }, 1 * 1000);
        }
[js]
</code></pre>

<h2>By running this example we will get the below result</h2>
i: 6i: 6i: 6i: 6i: 6i: 6
<h2>But why?</h2>
Because through <span class='quoted'>'closure'</span> the function inside setTimeout 
is using the the global variable <span class='quoted'>'i'</span> 

and as we have live copy of the <span class='quoted'>'i'</span> varible in each 
function call, every <span class='quoted'>'i'</span> value will get updated with 
the last value.
<h2>"how to solve it ?"</h2>
<li> 1. Using IIFI pattern: we need to use the "IIFE" pattern.</li>
<h2>ex</h2>
<pre><code>
[js]
          for (var i=1; i<= 5; i++) {
            (function(i){
              setTimeout(function(){
                console.log("i: " + i);
              }, i * 1000);
            })(i);
          }
[js]
</code></pre>

so now each of the <span class='quoted'>"setTimeout"</span> function will have 
iteration scope rather than <span class='quoted'>'global'</span> scope. 

<li> 2. Using "let" keyword:</li>
<pre><code>
[js]
        for (let i=1; i<5; i++) {
          setTimeout(function(){
            console.log("i: " + i);
          },i*1000);
        }
[js]
</code></pre>
what <span class='quoted'>'let'</span> keyword does is, it rebinds <span class='quoted'>'i'</span> for 
each <span class='quoted'>'iteration'</span> of <span class='quoted'>'for'</span> loop. 

<h2>"classic module pattern"</h2>
<h2>It has two characteristics</h2>
<li> 1. There must be an outer wrapping function that gets executed.(does not have to be a IIFE, but it does have to an outer function that gets executed).</li>
<li> 2. There must be one or more functions that get returned from that function call. So one or more inner functions that have the closure over the inner private scope.</li>
<h2>ex</h2>
<pre><code>
[js]
        var foo = (function() {
          var o = {bar: "bar"};

          return {
            bar: function() { //these stuffs are like
                              // private members of a
                              // module.
                              // And the obj "bar" is like
                              // an public API.

                              // There are one or more methods
                              // on the API, that have the
                              // special privilleged 'closure'
                              // capability that access the
                              // 'internal' state, and that
                              // makes a module.
              console.log(o.bar);
            }
          };
        })();

        foo.bar();
[js]
</code></pre>

So all the function is <span class='quoted'>'hidden'</span> from the outside world 
and we get choose what we return on our public <span class='quoted'>'API'.</span> 

 <span class='quoted'>"This pattern is useful in implementing encapsulation."</span> 
 <span class='quoted'>"This is the idea of hiding priviate implementation details"</span> 

<h2>"modified module pattern"</h2>
<pre><code>
[js]
      var foo = (function() {
        var publicAPI = {
          bar: function() {
            publicAPI.baz();;
          },
          baz: function() {
            console.log("baz");
          }
        };
        return publicAPI;
      })();
      foo.bar();   // "baz"
[js]
</code></pre>


<h2>"modern module pattern"</h2>
<pre><code>
[js]
      define("foo", function() {
        var o = {bar: "bar"};

        return {
          bar: function() {
            console.log(o.bar);
          }
        };
      });
[js]
</code></pre>

we have a named module <span class='quoted'>'foo'</span> and we are doing stuff on 
that.
This pattern when used using <span class='quoted'>"IIFE"</span> pattern, can only 
provide one instance, meaning its only for 

On the other hand if we use this pattern by using commonfunction and then assign the return value to differentvaribles, we will have different instance of the same module.
<h2>ex</h2>
<pre><code>
[js]
      var foo = function() {
        var publicAPI = {
          bar: function() {
            publicAPI.baz();;
          },
          baz: function() {
            console.log("baz");
          }
        };
        return publicAPI;
      };
      var myFoo = foo();
      var yourFoo = foo();

[js]
</code></pre>



<h2>Object Orienting</h2>

<li> 1. prototype:</li>
<h2>code</h2>
<pre><code>
[js]
        function Foo(who) {
          this.me = who;
        }
        Foo.prototype.identify = function() {
          return "I am " + this.me;
        };

        var a1 = new Foo("a1");
        var a2 = new Foo("a2");

        a2.speak = function() {
          alert("Hello, " + this.identify() + ".");
        };
        a1.constructor === Foo;
        a1.constructor === a2.constructor;
        a1.__proto__ === Foo.prototype;
        a1.__proto__ === a2.__proto__;

[js]
</code></pre>

Every single <span class='quoted'>"object"</span> is built by a constructor 
function.
Each time a constructor is called, a new object iscreated.
A constructor makes an object  <span class='quoted'>"based on"</span> its own 
prototype. <span class='quoted'>"based on"</span> is not completely true in case of 
JavaScript. <span class='quoted'>"based on"</span> implies that we take the prototype and 
we stamp out a copy of it.
This is true in <span class='quoted'>'class'</span> oriented languages. 

so  <span class='quoted'>'based on'</span> give us the wrong idea. 

<h2>A more appropriate way of saying the above thing is</h2>
- A constructor makes an object  <span class='quoted'>"linked to"</span> its own 
prototype.
*note*: while discussing the <span class='quoted'>'new'</span> keyword we said in 
the <span class='quoted'>'second'</span> step that it linked to an object. 

<h3>* Note *:</h3>
Before anything gets executed in the above code<h2>we already have somethings, which are</h2>
<li> 1. A function called 'Object' (capital 'O')</li>
<li> 2. An object which does not have any name, but a label named 'Object.prototype'.</li>

Object func ----".prototype"------> unnamed object 

The <span class='quoted'>"Object"</span> function has been linked to the object 
which does not have any name.
On the unnamed object, we have functions like<span class='quoted'>"toString"</span> and several values which are built in 
the language.
<h2>When the first line of above code gets executed</h2>
<li> 1. we will have a function called "Foo",</li>

<li> 2. its also going to create an "object" that we are linked to, and it will have the same arbitrary name: ".prototype".</li>

Foo func -------".prototype"-------> unnamed object 

Also the unnamed object is linked to theunnamed object of the <span class='quoted'>'Object'</span> function and this 
linkage is labeled as <span class='quoted'>"[[p]]".</span> 
 ("[[p]]"</span> is explained later in this notes) 


<li> 3. In addition to the above connection, there is also a connection in the opposite direction. The unnamed object has a property on the "function" called ".constructor".</li>

Foo function <------".constructor"---- unnamed object 

Most people think the <span class='quoted'>'.constructor'</span> means is 
constructed by. In other words the unnamed objectis constructed by the <span class='quoted'>"function".</span> 
 <span class='quoted'>"But its not true".</span> 

The word <span class='quoted'>'constructor'</span> is an arbitrary word 
it could have been any other random word.
So there is a <span class='quoted'>"two-way"</span> linkage. 

Now when we execute the <span class='quoted'>"Foo.prototype.identify = function()"</span> 
line, we put the <span class='quoted'>"identify"</span> property directly 
on the <span class='quoted'>"unnamed"</span> object. 

Now coming on the code  <span class='quoted'>"var a1 = new Foo('a1')"</span> 
Here we have encountered the <span class='quoted'>"new"</span> keyword. 
<h2>So four things will happen</h2>
<li> 1. brand new object will gets created.</li>
<li> 2. object gets linked to another object. (so the newly created object will get linked to the "unnamed object.")</li>
<li> 3. The contex gets set to the 'this'. So the newly created object will have a property called 'me', which will have the value 'a1'.</li>
<li> 4. We return 'this', which gets assigned to the variable 'a1' in the code. So now the name of the newly created object will be 'a1'.</li>

Now executing  <span class='quoted'>'a2.speak = function()'</span> 
This will put the <span class='quoted'>'speak'</span> property on the object 
which is <span class='quoted'>'a2'.</span> 

So at this point of time, if we try to execute<span class='quoted'>'a1.speak()',</span> it wont get executed as there is 
no property called <span class='quoted'>'speak'</span> on the <span class='quoted'>'a1'</span> object. 

Coming on to the code 
There is no direct property called <span class='quoted'>'constructor'</span> 
on the <span class='quoted'>'a1'</span> object. 
Some people think that there is a hidden propertycalled <span class='quoted'>'constructor'</span> on the <span class='quoted'>'a1'</span> object, but in 
reality its not there.So when we execute the above code, as there isno property called <span class='quoted'>'constructor'</span> on the <span class='quoted'>'a1'</span> object 
it will go up in the <span class='quoted'>"Prototypical"</span> chain. 
And the unnamed object has a linkage of <span class='quoted'>'.constructor'</span> 
so the call will end of being <span class='quoted'>'Foo'.</span> 
so 

The linkage of newly created object, such as <span class='quoted'>'a1',</span> 
with the unnamed object, which is linked with thefunction such as <span class='quoted'>'Foo'</span> using <span class='quoted'>'.prototype'</span> label, is 
called  <span class='quoted'>"Prototypical linkage".</span> 
In the specs this linkage is denoted by <span class='quoted'>"[[Prototype]]"</span> 
But in this notes we will say it [[P]] instead.
They are internal linkage, they are not visible topublic.
Now when we execute  <span class='quoted'>'a1.__proto__ === Foo.prototype'</span> 
The name for <span class='quoted'>'__proto__'</span> is <span class='quoted'>'dunder'.</span> 
The pronounciation of the above property is
So when the above code will get executed it will checkwhether <span class='quoted'>'a1'</span> have a  <span class='quoted'>'dunder proto'</span> property. 
As it does not have, it will go up in the Prototypicalchain and check the same thing on the unnamed object.As that object also does not have the  <span class='quoted'>'dunder proto'</span> 
property, so we will go up in the Prototypical chain,which happens to be the unnamed object of the<span class='quoted'>'Object'</span> function. 
Now on this object there is a property named<span class='quoted'>'__proto__'.</span> 
It turns out that it is not a property, rather itsa <span class='quoted'>'getter'</span> function. So the above code is a 
 <span class='quoted'>"function call".</span> 

This function returns the  <span class='quoted'>'internal prototype'</span> linkage 
of whatever the <span class='quoted'>'this'</span> binding is. 

So when we have called the <span class='quoted'>'__proto__'</span> function, the 
<span class='quoted'>'this'</span> keyword is <span class='quoted'>'a1'.</span> 

So this function  <span class='quoted'>"returns the internal prototype"</span> linkage 
of <span class='quoted'>'a1'.</span> 

So the <span class='quoted'>"[[P]]"</span> was the internal linkage and <span class='quoted'>'__proto__'</span> 
is the public linkage of <span class='quoted'>'a1'</span> with the unnamed object 
of the <span class='quoted'>'Foo'</span> function. 

So <span class='quoted'>'__proto__'</span> is the public property that references 
the internal characteristics.
The problem with  <span class='quoted'>'dunder proto'</span> is, it never been 
standardised.
But its a de-facto standard for every other browserexcept the <span class='quoted'>'IE'.</span> 

So we can see that <span class='quoted'>'a1.__proto__'</span> is same as 
<span class='quoted'>'Foo.prototype'.</span> 
The same goes for <span class='quoted'>'a2'.</span> 

As of <span class='quoted'>"ES5",</span> there is an standard utility 
<pre><code>
[js]
            a1.__proto__ === Object.getPrototypeOf(a1);
[js]
</code></pre>
So this utility extract the internal Prototypicallinkage for us.
So this utility is there for  <span class='quoted'>"IE > 8"</span> 
But what we will do for browsers < 8.
<h2>sol</h2>
<pre><code>
[js]
            a2.__proto__ == a2.constructor.prototype;
            // for IE < 8
[js]
</code></pre>

But the problem is,  <span class='quoted'>'both the property'</span> 
 <span class='quoted'>'the constructor property'</span> and  <span class='quoted'>'the prototype'</span> 
property are <span class='quoted'>'writable'</span> property. They happen 
to default to pointing where we discussed above.But when they gets over written, the above codefor  <span class='quoted'>"IE < 8"</span> is unreliable. 

<h2>code</h2>
<pre><code>
[js]
        function foo(who) {
          this.me = who;
        }
        Foo.prototype.identify = function() {
          return "I am " + this.me;
        };

        function Bar(who) {
          Foo.call(this, who);
        }
        // Bar.prototype = new Foo(); // or...
        Bar.prototype = Object.create(Foo.prototype);
        // NOTE: .constructor is broken here, need to fix

        Bar.prototype.speak = function() {
          alert("Hello, " + this.identify() + ".");
        };

        var b1 = new Bar("b1");
        var b2 = new Bar("b2");

        b1.speak(); // alerts: "Hello, I am b1."
        b2.speak(); // alerts: "Hello, I am b2."

[js]
</code></pre>

In the above code we wanted the class <span class='quoted'>"Bar"</span> to 
be the child of the <span class='quoted'>"Foo"</span> class. As we have written 
the function names in CAPS, they refer to the class.
We can achieve this by assigning what is there inthe comment in the code  <span class='quoted'>"// Bar.prototype = new Foo();"</span> 
But by this way we will unwantedly  <span class='quoted'>"call Foo every"</span> time. 

Soln is use the <span class='quoted'>'Object.create'.</span> 
The <span class='quoted'>'Object.create'</span> does the first two things of what 
<span class='quoted'>'new'</span> keyword does. 

In this code, when we call  <span class='quoted'>'var b1 = new Bar("b1")'.</span> 
<span class='quoted'>'this'</span> will point to <span class='quoted'>'b1'</span> 
So when we call <span class='quoted'>'b1.speak();'</span> it will check whether 
<span class='quoted'>'b1'</span> is having a <span class='quoted'>'speak'</span> property. No it does not have. 
Then it will go Prototypically up, and check whether<span class='quoted'>"Bar.prototype"</span> have <span class='quoted'>'speak'</span> property, and it is 
there on the <span class='quoted'>'Bar',</span> so it will call it. 

Now in the speak property, we have <span class='quoted'>'this.identify',</span> 
here <span class='quoted'>'this'</span> points to <span class='quoted'>'b1',</span> so we check whether <span class='quoted'>'b1'</span> 
has a <span class='quoted'>'identify'</span> property, as it does not have, we 
will go Prototypically up, and check if<span class='quoted'>"Bar.prototype"</span> has a identify property. 
No, so we traverse further up, and check whether<span class='quoted'>"Foo.prototype"</span> has a <span class='quoted'>'identify'</span> property, as it has 
it gets called.
But there is a drawback in this approach.We have lost the <span class='quoted'>'.constructor'</span> linkage. But how? 
As of line 6 in the above code we have the<span class='quoted'>'.constructor'</span> property but when we 
execute the code on line 12, we change thereference of the prototype object, and thenewly created one does not have a <span class='quoted'>'.constructor'</span> 
property.So we will delegate up to check  <span class='quoted'>'does the foo'</span> 
prototype has a <span class='quoted'>'.constructor',</span> yes it does and it 
is pointing to the <span class='quoted'>"Foo",</span> so we get <span class='quoted'>"Foo"</span> instead 
of <span class='quoted'>"Bar".</span> 

So this bizzare result proves that <span class='quoted'>".constructor"</span> 
does not mean 
an arbitrary property.

Now we can use the class pattern rather than the 
For this all the methods which were private in themodule pattern will now come to the  <span class='quoted'>"prototype of the class".</span> 

<h2>It is necessary to write the prototype like</h2>
<span class='quoted'>"ClassName.prototype.someMethod"</span> 
<h2>Because when we write like</h2>
<pre><code>
[js]
      ClassName.prototype = {
<h2>someMethod</h2>
      }
[js]
</code></pre>

We are actually overriding the prototype and thus we willloose the <span class='quoted'>'.constructor'</span> property. 

Generally we should always use the dynamic bindingprovided to us using <span class='quoted'>'this'</span> but there is one instance 
where we have to fallback to the lexical way ofdoing things.<h2>consider the below example</h2>
<pre><code>
[js]
        NotesManager.prototype.showHelp = function() {
          this.$help.show(); // $help is just a convention
                            // for saying that this variable
                            // belongs to JQuery.

          document.addEventListener("click", function __handler__(evt){
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();

            document.removeEventListener("click", __handler__, true);
            this.hideHelp();
          //}, true)
            }.bind(this),true)
        };

[js]
</code></pre>

Now when we call this function, the <span class='quoted'>'this'</span> in the 
last line of code  <span class='quoted'>"will not point"</span> to the reference 
we want, rather it will be the <span class='quoted'>'button'</span> on which 
the listener is being called.
To solve this problem we can use <span class='quoted'>'.bind'</span> function. 
So we do like the uncommented last line.
But in the event listener function we are <span class='quoted'>"removing the event listener"</span> using the <span class='quoted'>"named"</span> method. 
But due the  <span class='quoted'>"hard binding"</span> the  <span class='quoted'>"named function"</span> is <span class='quoted'>"not"</span> 
there.
<h2>So only in this case we do like below</h2>
<pre><code>
[js]
          NotesManager.prototype.showHelp = function() {
            var self = this;
            self.$help.show(); // $help is just a convention
                              // for saying that this variable
                              // belongs to JQuery.

            document.addEventListener("click", function __handler__(evt){
              evt.preventDefault();
              evt.stopPropagation();
              evt.stopImmediatePropagation();

              document.removeEventListener("click", __handler__, true);
              self.hideHelp();
            }, true)

[js]
</code></pre>

 <span class='quoted'>"But in general this is not a good practice"</span> 


<li> 2. Inheritance: Inheritance means that the child is having the copy of what the parent have.</li>

So its not wise to call  <span class='quoted'>"prototypal inheritance"</span> for 
JavaScript as we are not using the word inheritance forits correct meaning.
In JavaScript when we have the object arbitrarilycalled <span class='quoted'>'Foo.prototype'</span> and when we have <span class='quoted'>'a1'</span> and <span class='quoted'>'a2'</span> 
object, they are linked in the opposite way to whatinheritance does.<h2>In inheritance we have the below structure</h2>
 <span class='quoted'>"parent -----------> child"</span> 
meaning child is a copy of the parent.<h2>But in JS</h2>
 <span class='quoted'>"Foo.prototype <----------- child"</span> 
meaning the child is behaivirally linkedto the prototype.
This delegation in JS is a  <span class='quoted'>"design pattern"</span> and it is 
called 


<li> 2. OLOO: (Objects Linked to Other Objects)</li>
<h2>Consider the below code</h2>
<pre><code>
[js]
        function Foo(who) {
          this.me = who;
        }

        Foo.prototype.identify = function() {
          return "I am " + this.me;
        };

        function Bar(who) {
          Foo.call(this, who);
        }

        Bar.prototype = Object.create(Foo.prototype);

        Bar.prototype.speak = function() {
          alert("Hello, " + this.identify() + ".");
        };

        var b1 = new Bar("b1");
        b1.speak();

[js]
</code></pre>

In this code we only need to care about the threeobjects which are prototypically linked.
<span class='quoted'>"b1"</span> is linked to <span class='quoted'>"Bar.prototype".</span> 
<span class='quoted'>"Bar.prototype"</span> is linked to <span class='quoted'>"Foo.prototype".</span> 

Now the same thing can be achieved by using only the<span class='quoted'>"objects"</span> rather than the <span class='quoted'>"constructor".</span> 

As a first step towards refinement we will removethe <span class='quoted'>'new'</span> keyword. 
<h2>The refined code will look like the below</h2>
<pre><code>
[js]
          function Foo(who) {
            this.me = who;
          }

          Foo.prototype.identify = function() {
            return "I am " + this.me;
          };

          function Bar(who) {
            Foo.call(this, who);
          }

          Bar.prototype = Object.create(Foo.prototype);

          Bar.prototype.speak = function() {
            alert("Hello, " + this.identify() + ".");
          };

          var b1 = Object.create(Bar.prototype);
          Bar.call(b1, "b1");
          b1.speak();
[js]
</code></pre>

In this refinment remove the <span class='quoted'>'new'</span> keyword and 
instead use the <span class='quoted'>'Object.create'</span> utility to 
create a  <span class='quoted'>"brand new object"</span> and <span class='quoted'>"link"</span> the object to 
the <span class='quoted'>"prototype".</span> 

Then we explicitly bind the <span class='quoted'>'Bar'</span> <span class='quoted'>'this'</span> to <span class='quoted'>'b1'.</span> 

<h2>Consider the second refinment below</h2>
<pre><code>
[js]
          function Foo(who) {
            this.me = who;
          }

          Foo.prototype.identify = function() {
            return "I am " + this.me;
          };

          //changed
          var Bar = Object.create(Foo.prototype);
          Bar.init = function(who) {
            Foo.call(this, who);
          };

          // changed
          Bar.speak = function() {
            alert("Hello, " + this.identify() + ".");
          };

          var b1 = Object.create(Bar); // changed
          b1.init("b1"); // changed
          b1.speak();
[js]
</code></pre>

In this refinment, we have ditched the function <span class='quoted'>"Bar"</span> 
and made <span class='quoted'>"Bar"</span> an object instead. 

<h2>Consider the third refinment</h2>
<pre><code>
[js]
          var Foo = {
            init: function(who) {
              this.me = who;
            },
            identify: function() {
              return "I am " + this.me;
            }
          };

          var Bar = Object.create(Foo);

          Bar.speak = function() {
            alert("Hello, " + this.identify() + ".");
          };

          var b1 = Object.create(Bar);
          b1.init("b1");
          b1.speak();
[js]
</code></pre>

Now these are peer objects that can delegate toeach other.
<li> 3. Object.create:</li>
<pre><code>
[js]
      if (!Object.create) {
        Object.create = function(o) {
          function F() {}
          F.prototype = o;
          return new F();
        };
      }
[js]
</code></pre>


<h2>Async Patterns</h2>
<li> 1. Callbacks</li>
<li> 2. Generators / Coroutines</li>
<li> 3. Promises</li>

<li> 1. Callbacks:</li>

<h2>"callback hell"</h2>
<h2>consider the below code</h2>
<pre><code>
[js]
          setTimeout(function(){
            console.log("one");
            setTimeout(function(){
              console.log("two");
              setTimeout(function(){
                console.log("three");
              }, 1000);
            }, 1000);
          }, 1000);

[js]
</code></pre>

<h2>*Note*</h2>
callback hell does not have anything to do withnesting.
<h2>consider the below code</h2>
<pre><code>
[js]
          function one(cb) {
            console.log("one");
            setTimeout(cb, 1000);
          }

          function two(cb) {
            console.log("two");
            setTimeout(cb, 1000);
          }

          function three() {
            console.log("three");
          }

          one(function(){
            two(three)
          });
[js]
</code></pre>

<h2>"Inversion of control"</h2>
When we loose controll over a program to let itexecute by some third party library.
<h2>"Solving callback problems"</h2>
<li> 1. separate callbacks:</li>
<pre><code>
[js]
          function trySomething(ok, err) {
            setTimeout(function(){
              var num = Math.random();
              if (num > 0.5) ok(num);
              else err(num);
            }, 1000);
          }

          trySomething(
            function(num){
              console.log("Success: " + num);
            },

            function(num){
              console.log("Sorry: " + num);
            }
          );
[js]
</code></pre>
In this we expect the third party library tocall one method when there is <span class='quoted'>"success"</span> and 
the other when there is <span class='quoted'>"failure".</span> 
But this is more  <span class='quoted'>"implicit trust",</span> because 
we are trusting the them that they will call <span class='quoted'>"only one method".</span> But what will happen when they 
call both the methods:  <span class='quoted'>"Our code will break".</span> 

<li> 2. error-first style:</li>
<pre><code>
[js]
          function trySomething(cb) {
            setTimeout(function(){
              var num = Math.random();
              if (num > 0.5) cb(null, num);
              else cb("Too low!");
            }, 1000);
          }

          trySomething(function(err, num){
            if (err) {
              console.log(err);
            }
            else{
              console.log("Number: " + num);
            }
          });
[js]
</code></pre>
In this code we have only  one function.So we are only checking for the <span class='quoted'>'error'</span> object. 

But consider a scenario when they return an errorobject and then a success value.In this situation we will reject the success valueas we are only checking for the error object.

<li> 2. Generators (yield) ("ES6"):</li>
<h2>consider the below code</h2>
<pre><code>
[js]
        function* gen() {
          console.log("hello");
          yield null;
          console.log("World");
        }

        var it = gen();
        it.next(); // prints "Hello"
        it.next(); // prints "World"
[js]
</code></pre>
so calling the <span class='quoted'>"gen"</span> function, creates an <span class='quoted'>"iterator".</span> 
so when we call <span class='quoted'>"it.next()"</span> it will start from the 
line 2 and execute till it encounters a <span class='quoted'>'yield'</span> statement. 
The second <span class='quoted'>'it.next()'</span> will also run till it encounters 
a <span class='quoted'>'yield'</span> statement or till end of the program. 

<span class='quoted'>'yield'</span> is used for  <span class='quoted'>"two way message passing".</span> 
meaning we can pass value to <span class='quoted'>'yield'</span> from outside 
and <span class='quoted'>'yield'</span> can also return value to the calling function. 

<h2>consider the below code</h2>
<pre><code>
[js]
        var run = coroutine(function* (){
          var x = 1 + (yield null);
          var y = 1 + (yield null);
          yield(x + y);
        });

        run();
        run(10);
        console.log("something: " + run(30).value);
[js]
</code></pre>

So when first run() will be called, the <span class='quoted'>'yield'</span> will 
return <span class='quoted'>'null'</span> to the function. 

When we call run(10), the value of the previous <span class='quoted'>'yield'</span> 
expression will be 10.So the value of 

and it encounters the next <span class='quoted'>'yield'</span> and <span class='quoted'>'null'</span> will get 
returned to <span class='quoted'>'run(10)'</span> 

now when <span class='quoted'>'run(30)'</span> will get executed, 30 will get 
substituted for the <span class='quoted'>'yield'</span> expression and 


Then it encounters the next <span class='quoted'>'yield'</span> and (x + y) will 
be returned which is <span class='quoted'>'42'.</span> 

Till now everything was looking <span class='quoted'>"synchronous"</span> in 
generators.
<h2>consider the below code</h2>
<pre><code>
[js]
        function getData(d) {
          setTimeout(function() {run(d);}, 1000);
        }

        var run = coroutine(function* (){
          var x = 1 + (yield getData(10));
          var y = 1 + (yield getData(30));
          var answer = (yield getData("something: " + (x + y)));
          console.log(answer);
        });

        run();
[js]
</code></pre>

<li> 3. Promises:</li>
<h2>JQuery style Promises</h2>
<pre><code>
[js]
        var wait = jQuery.Deferred();
        var p = wait.promise();

        // this happens when we listen for an event
        // continuation event
        p.done(function(value) {
          console.log(value);
        });

        // when we call resolve on Deferred, it will
        // automatically fires the 'done' event for
        // any promises that are listening to it.
        setTimeout(function(){
          wait.resolve(Math.random());
        }, 1000);
[js]
</code></pre>

<h2>ex</h2>
<pre><code>
[js]
        function waitForN(n) {
          var d = $.Deferred();
          setTimeout(d.resolve, n);
          return d.promise();
        }

        // promise gets returned from the
        // waitForN function, and when we call
        // '.then' we are listening for the
        // continuation event on that returned promise.
        waitForN(1000).then(function() {
          console.log("hello world");
          return waitForN(2000);
        })
        .then(function(){
          console.log("finally!");
        });
[js]
</code></pre>

Promises un-invert the  <span class='quoted'>'inversion of control'</span> 


<h2>prob</h2>
Make three request to fetch some data from filesasyncronously, but display them in the give order.
<h2>sol</h2>
For this problem we need to track the internalstate of the call, if we are using <span class='quoted'>'callbacks'.</span> 



<h2>How event loop works in JS</h2>
<h2>Our browser have following things</h2>
<li> 1. call stack (js runtime)</li>
<li> 2. WebAPIs (ex: setTimeout, DOM(document), ajax(XMLHttpRequest))</li>
<li> 3. event loop</li>

Actually JS is single threaded.<h2>So when we execute some things such as the below code</h2>
<pre><code>
[js]
      console.log("hiii there");
      function foo() {
        console.log("hello");
      }
      function bar() {
        console.log("there");
        foo();
      }
      function baz() {
        console.log("hi");
        bar();
      }
      baz();
[js]
</code></pre>

<h2>How these things are executed by the JS runtime is</h2>
<li> 1. At first 'main()' will appear in the stack. 'main()' is the anonymous function corresponding to the file itself.</li>
<li> 2. then 'console.log("hiii there")' will appear in the "stack".</li>
<li> 3. then "baz()"</li>
<li> 4. then 'console.log("hi")'</li>
<li> 5. then 'bar()'</li>
<li> 6. then 'console.log("there")' and like that.</li>

<h2>But consider the below code</h2>
<pre><code>
[js]
      console.log("hii there");
      setTimeout(function foo() {
        console.log('hello there')
      });
      console.log("hii")
[js]
</code></pre>

how will this code gets executed?<h2>When we check the 'call stack' we will find</h2>
<li> 1. console.log("hii there") will get executed.</li>
<li> 2. setTimeout(function foo() { console.log('hello there') }); will get executed but it will disappear from the stack before executing console.log('hello there').</li>
<li> 3. then console.log("hii") will get executed.</li>

But where does that setTimeout function went?
Actually <span class='quoted'>'setTimeout'</span> is a function defined in <span class='quoted'>"WebAPI"</span> 
not in actual  <span class='quoted'>"JS runtime".</span> 

So the function after leaving the  <span class='quoted'>'call stack'</span> will 
enter into the <span class='quoted'>"WebAPI"</span> and that <span class='quoted'>'api'</span> will keep track 
of the <span class='quoted'>'timer'.</span> 
When the timer is complete, as it can not directly modifythe 
 <span class='quoted'>"event loop"</span> or  <span class='quoted'>"task queue".</span> 

 <span class='quoted'>"Event loop"</span> has to wait till the stack is clear, before 
it can push the <span class='quoted'>'callback'</span> on the  <span class='quoted'>"call stack".</span> 

<span class='quoted'>"setTimeout"</span> is not a guranteed time of execution, it is 
minimum time of execution.
When we block the stack with some <span class='quoted'>'slow'</span> work, the 
browser does not render, (render queue gets stopped).
So during that time, nothing will work, no buttons, noselection, nothing.
Where in case of asyncronous call, browser gets a chanceto re-render after every call.


